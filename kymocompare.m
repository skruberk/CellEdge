function [cross_corr,lag] = kymocompare(kymo1,k1_max,kymo2,k2_max)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% kymo1 and kymo2 need to be declared as global variables at the command
% line when droid5 is run, otherwise they aren't saved in the base
% workspace to run in kymocompare
%
% calculate line-by-line cross correlation IN THE TIME DIMENSION between 
% two kymographs and then average the resuls across the spatial dimension. 
% This function makes use of the kymimage() function (included in file)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% INPUTS
% kymo1 and kymo2 are kymograph cell arrays generated by droidx.m
% k1_max and k2_max are maximum values of kymo intensity used for plotting
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% OUTPUT
% cross_corr -- is the line-by-line cross correlation in time between the
%           two kymographs, averaged over the entire spatial dimension

% first, convert raw kymographs into aligned kymograph images
ch1kymo = kymimage(kymo1,1,k1_max);
ch2kymo = kymimage(kymo2,1,k2_max);
% get the dimensions of the kymographs (assume both are the same size)
k1size = size(ch1kymo);
k2size = size(ch2kymo);
% if the sizes to not match, bail out
if k1size ~= k2size
    'ERROR: kymograph dimensions do not match'
    return
end
% initialize the output vector
cross_corr = zeros(1,2*k1size(2)-1);
storecross = {};
% run through all the time lines in the image %%%%%%%%%%%%%%%%%%%%%%%%%%%
% count the number of lines appropriate for analysis
jk = 0;
for k=1:k1size(1)
    % count the zeros in the current line
    zcount=ch1kymo(k,:)==0;
    znum=sum(zcount(:));
    % check to see if less than 5% of the elements are zero
    if znum<(0.05*k1size(2))
        % if there aren't too many zeros then analyze this line
        jk=jk+1;
        tl1 = ch1kymo(k,:);
        tl2 = ch2kymo(k,:);
        % adjust the data to have a mean of zero
        tl1 = tl1 - mean(tl1);
        tl2 = tl2 - mean(tl2);
        % normalize the data
        tl1 = tl1/(mean(abs(tl1)));
        tl2 = tl2/(mean(abs(tl2)));
        % compute the cross correlation
        [r,lag] = xcorr(tl1,tl2,'biased');
        cross_corr = cross_corr + r/sqrt(3);
        storecross= cross_corr
    end
end
jk
% divide by the number of lines analyzed to get the average correlation
cross_corr = cross_corr/jk;
figure;
plot(lag,cross_corr)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


end



function im_kym = kymimage(kym,stretch,imax)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% build a kymograph image from a kymograph data cell array.
% im_kym - is the output image file
% kym - is the input kymograph cell structure
% stretch - is how much to stretch the time dimension
% imax - is the maximum intensity for image scaling

% initialize a few things
% nf is the number of frames in the movie. This algorithm fails if the
% number of frames is fewer than 4 (the number of fields in kym)
nf = length(kym);
% lengths and offsets are track lengths and registration offsets
offsets = zeros(nf,1);
lengths = zeros(nf,1);
% load the lengths and offests into vectors for convenience
for i=1:nf
    lengths(i) = kym{i,1};
    offsets(i) = kym{i,4};
end
% calculate the positions of the top and bottom edges of the kymo
top_edg = min([min(offsets) 0]);
bot_edg = max(lengths+offsets);
% calculate the maximum length needed to hold all of the aligned kymos
width = bot_edg - top_edg;

% initialize the image
im_kym = zeros(width,stretch*nf);

for i=1:nf
    % the commented code centers the lines of the kymo which is a mistake
    %init = 1+floor((width-kymo{i,1})/2);
    for j=1:stretch
        lnst = offsets(i)-top_edg+1;
        im_kym(lnst:lnst+lengths(i)-1,1+(i-1)*stretch+j-1) = kym{i,3};
    end
end

% normalize image data for 256-color plotting
temp = 256*(im_kym./imax);
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% make custom color map
% N.B. the old color map was just jet(128). The new one is similar to
% jet(128) but expands the contrast in the low signal region
pmap1=jet(128);
pmap2=hot(256);
pmap2=flipud(pmap2);
cmap=[pmap1(1:80,:);pmap2(64:239,:)];
pmap1=jet(128);
pmap2=hot(256);
pmap2=flipud(pmap2);
cmap=[pmap1(1:80,:);pmap2(64:239,:)];
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% new figure
figure;
imshow(temp,[0 256],'colormap',cmap);
colorbar;
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
return
end